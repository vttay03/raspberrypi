/*
 * ssd1306.c
 *
 *  Created on: Jun 23, 2012
 *      Author: taylor
 */

#include <stdio.h>

#include <linux/spi/spidev.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <wiringPi.h>

// User-defined headers
#include "font8x8.h"

#include "ssd1306.h"

// pin assignments for wiringPi
#define RST 4
#define DC 5
#define CS 1

#define _BV(bit) (1 << bit)

// the memory buffer for the LCD

static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#if (SSD1306_LCDHEIGHT == 64)
0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
};

unsigned char spi_bytes[8];

int c_spi_write(unsigned char* bytes, unsigned int length) {
    int fd; // I tested with a persistent filehandle; no real difference.
    int ret;

    // for debugging:
    // for (i=0; i < length; i++) {
    //    printf("%x ", bytes[i]);
    // }
    // printf("\n");

    // See /usr/include/linux/spi/spidev.h for documentation..

    fd = open("/dev/spidev0.0", O_RDWR);
    if (fd == -1) {
        perror("Error opening /dev/spidev0.0");
        exit(2);
    }

    u_int8_t bits = 8;
    u_int16_t delay = 0;
    // 20 MHz seems to work nicely, but maybe some controllers will want
    // slower speeds? Adjust downwards if you encounter trouble.
    u_int32_t speed = 20000000;
    // uint8_t tx[4096];

    struct spi_ioc_transfer tr = {
        .tx_buf = (unsigned long)bytes,
        .rx_buf = (unsigned long)NULL,
        .len = length,
        .delay_usecs = delay,
        .speed_hz = speed,
        .bits_per_word = bits,
    };

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
    if (ret == -1) {
        perror("failed to send SPI");
        exit(2);
    }
    if (close(fd) == -1) {
        perror("failed to close SPI filehandle");
        exit(2);
    }
    return ret;
}

/**************************************************************
 * Name: init_display
 * 
 * Description: Initializes SSD1306 OLED display after power-up
 * 
 * @param struct gpioID selected_GPIOs[]
 * 
 * Returns: nothing
 * ************************************************************/
void init_display() {

#if defined SSD1306_128_32
	unsigned char init_chars[] = {
			SSD1306_DISPLAYOFF,
			SSD1306_SETDISPLAYCLOCKDIV,
			0x80,
			SSD1306_SETMULTIPLEX,
			0x1F,
			SSD1306_SETDISPLAYOFFSET,
			0x0,
			SSD1306_SETSTARTLINE,
			SSD1306_CHARGEPUMP,
			0x14,
			SSD1306_MEMORYMODE,
			0x00,
			SSD1306_SEGREMAP | 0x1,
			SSD1306_COMSCANDEC,
			SSD1306_SETCOMPINS,
			0x02,
			SSD1306_SETCONTRAST,
			0x8F,
			SSD1306_SETPRECHARGE,
			0xF1,
			SSD1306_SETVCOMDETECT,
			0x40,
			SSD1306_DISPLAYALLON_RESUME,
			SSD1306_NORMALDISPLAY,
			SSD1306_DISPLAYON};
#endif

#if defined SSD1306_128_64
	unsigned char init_chars[] = {
			SSD1306_DISPLAYOFF,
			SSD1306_SETDISPLAYCLOCKDIV,
			0x80,
			SSD1306_SETMULTIPLEX,
			0x3F,
			SSD1306_SETDISPLAYOFFSET,
			0x0,
			SSD1306_SETSTARTLINE,
			SSD1306_CHARGEPUMP,
			0x14,
			SSD1306_MEMORYMODE,
			0x00,
			SSD1306_SEGREMAP | 0x1,
			SSD1306_COMSCANDEC,
			SSD1306_SETCOMPINS,
			0x12,
			SSD1306_SETCONTRAST,
			0xCF,
			SSD1306_SETPRECHARGE,
			0xF1,
			SSD1306_SETVCOMDETECT,
			0x40,
			SSD1306_DISPLAYALLON_RESUME,
			SSD1306_NORMALDISPLAY,
			SSD1306_DISPLAYON};
#endif


	printf("Resetting OLED Display...\n");
	// Reset display (active low)
	digitalWrite(RST, HIGH);
	sleep(1);
	digitalWrite(RST, LOW);
	sleep(1);
	digitalWrite(RST, HIGH);
	printf("Reset Complete!\n");

	// Send SPI command bytes
	
	// set D/C bit low for command
	digitalWrite(DC, LOW);
	c_spi_write(init_chars, sizeof(init_chars));
	
	return;
}
 
/**************************************************************
 * Name: set_display
 * 
 * Description: sets display background/inversion parameter
 * 
 * @param struct gpioID selected_GPIOs[]
 * @param val (0 = black background, 1 = white background)
 * 
 * Returns: nothing
 * ************************************************************/
void set_display(int val) {

	// Set D/C bit low for command
	digitalWrite(DC, LOW);

	if ( val == 1) { //  invert display
		spi_bytes[0] = 0xA7;
		c_spi_write(spi_bytes, 1);
	}
	else { // normal display
		spi_bytes[0] = 0xA6;
		c_spi_write(spi_bytes, 1);
	}
	return;
}

/**************************************************************
 * Name: update_display
 *
 * Description: writes buffer to display
 *
 *
 * Returns: nothing
 * ************************************************************/
void update_display()
{
	int i;

	// Send command
	digitalWrite(DC, LOW); // D/C bit low for command

	spi_bytes[0] = (SSD1306_SETLOWCOLUMN | 0x0);
	spi_bytes[1] = (SSD1306_SETHIGHCOLUMN | 0x0);
	spi_bytes[2] = (SSD1306_SETSTARTLINE | 0x0);

	c_spi_write(spi_bytes, 3); // send command

	digitalWrite(DC, HIGH); // D/C bit high for data

	for(i = 0;i < (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++)
	{
		spi_bytes[0] = buffer[i];
		c_spi_write(spi_bytes, 1); // send display buffer
	}

	return;
}

/**************************************************************
 * Name: clear_display
 *
 * Description: writes an array of 0x00 chars to display to clear
 * 				static after initialization
 *
 * @param struct gpioID selected_GPIOs[]
 *
 * Returns: nothing
 * ************************************************************/
void clear_display() {
      int i, j;

      // Set D/C bit high for data
      digitalWrite(DC, HIGH);

      for (i = 0; i < sizeof(buffer); i+=8) {
    	  for(j=0;j<8;j++)
    	  {
    		  buffer[i+j] = oledchars[0][j];
    	  }
      }
      update_display();
}


/**************************************************************
 * Name: print_char
 * 
 * Description: writes a single character to SSD1306 display
 * 
 * @param struct gpioID selected_GPIOs[]
 * @param data (character to write to display)
 * @param pos (valid entries are 0 - 63, 4 lines of 16 chars ea.)
 * 
 * Notes: 	OLED Display is 128 x 32, each character is 8 x 8
 * 			Position 0 = Line 0, Position 0
 * 			Position 16 = Line 1, Position 0
 * 			Position 63 = Line 3, Position 15
 * 
 * Returns: nothing
 * ************************************************************/
void print_char(unsigned char data, int pos){

	int i;
	unsigned char temp;

	// Send character position command(s)
	digitalWrite(DC, LOW); // D/C bit low for command

	// Set Column Start/End Addresses
	spi_bytes[0] = 0x21; // Set Column Address command
	temp = (pos*8) - ((pos/16)*128); // e.g. 50 = 400 - 384 = 16
    spi_bytes[1] = temp; // Column Start Address
	spi_bytes[2] = (temp + 8); // Column End Address
	c_spi_write(spi_bytes, 3);	

	// Set Page Start/End Addresses
	spi_bytes[0] = 0x22;
	temp = pos/16;
	spi_bytes[1] = temp; // Page Start Address
	spi_bytes[2] = 0x03; // Page End Address
	c_spi_write(spi_bytes, 3);
	
	// Send data
	digitalWrite(DC, HIGH); // D/C bit high for data
	for(i = 0;i < 8;i++){ // assign data bytes
		spi_bytes[i] = oledchars[data][i];
	}
	c_spi_write(spi_bytes, 8);

	return;
}


/**************************************************************
 * Name: print_line
 * 
 * Description: writes an entire line to the SSD1306 display
 * 
 * @param struct gpioID selected_GPIOs[]
 * @param line (line of text to write to display)
 * @param num (valid entries are 0 - 3 since there are 4 lines)
 * 
 * Returns: nothing
 * ************************************************************/
void print_line(char *line, int num) {

	int i,j,fontbyte,pos;
	unsigned char data;
	int length = (int)strlen(line);
	
	pos = num*64; // buffer is 64 deep so divide into sections of 8 for 8x8 font

	// Update buffer with data
	for(i = 0;i < length;i++){
		data = line[i];
		fontbyte=0;
		for (j = (pos+i*8); j < (pos+(i*8+8)); j++){
			buffer[pos+j] = oledchars[data][fontbyte];
			fontbyte++;
		}
	}

	// Fill rest of the line with blank data
//	for(i = 0;i < (16-length);i++) {
//		data = 0;
//		for(j = 0;j < 8;j++) {
//			buffer[j] = oledchars[data][j];
//		}
//	}
	update_display();

	return;
}

/**************************************************************
 * Name: drawPixel
 *
 * Description: writes an entire line to the SSD1306 display
 *
 * @param x
 * @param y
 * @param color
 *
 * Returns: nothing
 * ************************************************************/
// the most basic function, set a single pixel
void drawPixel(int16_t x, int16_t y, uint16_t color)
{
  if ((x < 0) || (x >= SSD1306_LCDWIDTH) || (y < 0) || (y >= SSD1306_LCDHEIGHT))
    return;

  // check rotation, move pixel around if necessary
//  switch (getRotation()) {
//  case 1:
//    swap(x, y);
//    x = SSD1306_LCDWIDTH - x - 1;
//    break;
//  case 2:
//    x = SSD1306_LCDWIDTH - x - 1;
//    y = SSD1306_LCDHEIGHT - y - 1;
//    break;
//  case 3:
//    swap(x, y);
//    y = SSD1306_LCDHEIGHT - y - 1;
//    break;
//  }

  // x is which column
  if (color == WHITE)
    buffer[x+ (y/8)*SSD1306_LCDWIDTH] |= _BV((y%8));
  else
    buffer[x+ (y/8)*SSD1306_LCDWIDTH] &= ~_BV((y%8));
}

/**************************************************************
 * Name: drawLine
 *
 * Description: writes an entire line to the SSD1306 display
 *
 * @param x0
 * @param y0
 * @param x1
 * @param y1
 * @param color
 *
 * Returns: nothing
 * ************************************************************/
// Bresenham's algorithm - thx wikpedia
void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color)
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
      drawPixel(y0, x0, color);
    } else {
      drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}

/* ENTRY POINT */
int main (int argc, char *argv[]){

	int i;

	// wiringPi setup function
	if (wiringPiSetup () == -1)
		exit (1) ;

	// setup wiringPi pins needed for OLED comms to output
	pinMode(RST, OUTPUT);
	pinMode(DC, OUTPUT);
	pinMode(CS, OUTPUT);

	// set chip select pin (active low)
	digitalWrite(CS, LOW);

	// Parse command-line options, assume no errors since no one else in the world will be using this application
	for (i=1;i<argc;i++) {// start at index 1 because 0 is name of application
		if ( strcmp(argv[i], "--init") == 0 || strcmp(argv[i], "--cleanup") == 0 ) {
			init_display();
			clear_display();
			break;
		}
		else if ( strcmp(argv[i], "--line") == 0) { // argv[2] = text, argv[3] = line number
			clear_display();
			print_line(argv[2], atoi(argv[3])); // atoi converts string to integer
			break;
		}
		else if ( strcmp(argv[i], "--char") == 0) {	// argv[2][0] = character, argv[3] = character position
			clear_display();
			print_char(argv[2][0], atoi(argv[3]));
			break;
		}
		else if ( strcmp(argv[i], "--display") == 0) { // set display 0 = normal, 1 = invert
			set_display(atoi(argv[2]));
			break;
		}
		else
			printf ("Error: Invalid Argument\n");
	}
	
	// reset chip select pin (active low)
	digitalWrite(CS, HIGH);

	return 0;
}


